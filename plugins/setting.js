const { updateEnv, readEnv } = require('../lib/database'); const EnvVar = require('../lib/mongodbenv'); const { cmd } = require('../command'); const sensitiveData = require('../dila_md_licence/a/b/c/d/dddamsbs'); async function handleUpdate(reply, key, newValue, validation, errorMsg) { if (validation && !validation(newValue)) { return reply(errorMsg); } try { await updateEnv(key, newValue); reply(`*This is success...âœ…*\n${newValue}`); } catch (err) { console.error(`Error updating ${key}: ` + err.message); reply(`ğŸ™‡â€â™‚ï¸ *Failed to update ${key}. Please try again.*\n` + err); } } cmd({ pattern: "settings", alias: ["setting"], react: "ğŸ—ï¸", desc: "Check bot online or not.", category: "main", filename: __filename }, async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => { try { return await conn.sendMessage(from, { image: { url: 'https://telegra.ph/file/959a00b8f92106a8856de.jpg' }, caption: `*${sensitiveData.ahahabsbsbdb}*\n\nğ—¬ğ—¢ğ—¨ğ—¥ ğ—¦ğ—˜ğ—§ğ—§ğ—œğ—¡ğ—šğ—¦\ntype - .mysetting\n\nğ—¢ğ—ªğ—¡ğ—˜ğ—¥ ğ—¡ğ—”ğ— ğ—˜\nex - .ownername ${sensitiveData.ajababaaaaaa}\n\nğ—¢ğ—ªğ—¡ğ—˜ğ—¥ ğ—¡ğ—¨ğ— ğ—•ğ—˜ğ—¥\nex - .ownernumber 94777xxxxxx\n\nğ—¢ğ—ªğ—¡ğ—˜ğ—¥ ğ—™ğ—¥ğ—¢ğ— \nex - .ownerfrom matara\n\nğ—¢ğ—ªğ—¡ğ—˜ğ—¥ ğ—”ğ—šğ—˜\nex - .ownerage 20\n\nğ—¢ğ—ªğ—¡ğ—˜ğ—¥ ğ—–ğ—¢ğ— ğ— ğ—”ğ—¡ğ——\nex - .ownercommand dilo\n\nğ—”ğ—Ÿğ—œğ—©ğ—˜ğ—œğ— ğ—š\nex - .aliveimg (img url)\n\nğ—”ğ—Ÿğ—œğ—©ğ—˜ğ— ğ—¦ğ—š\nex - .alivemsg (your alive msg)\n\nğ—£ğ—¥ğ—˜ğ—™ğ—œğ—«\nex - .prefix,*&%$#\n\nğ—”ğ—¨ğ—§ğ—¢ğ—¦ğ—§ğ—”ğ—§ğ—˜ğ—¦\n*true or false*\nex - .autostates true\n\nğ— ğ—¢ğ——ğ—˜\n*private, public, groups, inbox*\nex - .mode public\n\nğ—”ğ—¨ğ—§ğ—¢ğ—©ğ—¢ğ—œğ—–ğ—˜\n*true or false*\nex - .autovoice true\n\nğ—”ğ—¨ğ—§ğ—¢ğ—œğ— ğ—š\n*true or false*\nex - .autoimg true\n\nğ—”ğ—¨ğ—§ğ—¢ğ—©ğ—œğ——ğ—˜ğ—¢\n*true or false*\nex - .autovideo true\n\nğ—”ğ—¨ğ—§ğ—¢ğ—¦ğ—§ğ—œğ—–ğ—ğ—˜ğ—¥\n*true or false*\nex - .autosticker true\n\nğ—”ğ—¨ğ—§ğ—¢ğ—¥ğ—˜ğ—£ğ—Ÿğ—¬\n*true or false*\nex - .autoreply true\n\nğ—”ğ—œğ—–ğ—›ğ—”ğ—§\n*true or false*\nex - .aichat true\n\nğ—ªğ—”ğ—¥ğ—¡ğ—–ğ—¢ğ—¨ğ—¡ğ—§\nex - .warncount 10\n\nğ—”ğ—¡ğ—§ğ—œğ—Ÿğ—œğ—¡ğ—\n*delete, warn, kick, off*\nex - .antilink delete\n\nğ—”ğ—¡ğ—§ğ—œğ—•ğ—”ğ——\n*delete, warn, kick, off*\nex - .antibad delete\n\nğ—”ğ—¡ğ—§ğ—œğ—©ğ—¢ğ—œğ—–ğ—˜\n*delete, warn, kick, off*\nex - .antivoice delete\n\nğ—”ğ—¡ğ—§ğ—œğ—¦ğ—§ğ—œğ—–ğ—ğ—˜ğ—¥\n*delete, warn, kick, off*\nex - .antisticker delete\n\nğ—”ğ—¡ğ—§ğ—œğ—œğ— ğ—š\n*delete, warn, kick, off*\nex - .antiimg delete\n\nğ—”ğ—¡ğ—§ğ—œğ—©ğ—œğ——ğ—˜ğ—¢\n*delete, warn, kick, off*\nex - .antivideo delete` }, { quoted: mek }); } catch (e) { console.log(e); reply(`${e}`); } }); cmd({ pattern: "mysettings", alias: ["mysetting","botsettings","botsetting"], desc: "List all current bot settings", category: "owner", react: "ğŸ“œ", thumbnail: "https://telegra.ph/file/959a00b8f92106a8856de.jpg", filename: __filename }, async (conn, mek, m, { reply, isOwner }) => { if (!isOwner) return reply("_à¶”à¶¶ à¶¶à·œà¶§à·Š à·„à·’à¶¸à·’à¶šà¶»à·” à¶±à·œà·€à·š...ğŸš«_"); try { const allEnvVars = await EnvVar.find({}); const envList = allEnvVars.map(env => `${env.key}: ${env.value}`).join('\n'); return reply(`ğ—¬ğ—¢ğ—¨ğ—¥ ğ—¦ğ—˜ğ—§ğ—§ğ—œğ—¡ğ—š\n\n${envList}`); } catch (err) { console.error('Error fetching environment variables: ' + err.message); return reply("ğŸ™‡â€â™‚ï¸ *Failed to fetch settings. Please try again.*"); } }); cmd({ pattern: "ownernumber", desc: "Update the owner's WhatsApp number", category: "owner", react: "âœ…", filename: __filename }, async (conn, mek, m, { q, reply, isOwner }) => { if (!isOwner) { return reply("_à¶”à¶¶ à¶¶à·œà¶§à·Š à·„à·’à¶¸à·’à¶šà¶»à·” à¶±à·œà·€à·š...ğŸš«_"); } if (!q) { return reply("Please set your number using the correct format:\n\nExample: `.ownernumber 94777xxxxxx`"); } const formattedNumber = q.endsWith('@s.whatsapp.net') ? q : `${q}@s.whatsapp.net`; const key = 'OWNER_NUMBER'; handleUpdate(reply, key, formattedNumber, val => val.endsWith('@s.whatsapp.net'), "ğŸ˜“ *Invalid WhatsApp number format.* Please use: `94777xxxxxx`"); }); cmd({ pattern: "aliveimg", desc: "Update the alive image URL", category: "owner", react: "âœ…", filename: __filename }, async (conn, mek, m, { q, reply, isOwner }) => { if (!isOwner) { return reply("_à¶”à¶¶ à¶¶à·œà¶§à·Š à·„à·’à¶¸à·’à¶šà¶»à·” à¶±à·œà·€à·š...ğŸš«_"); } if (!q) { return reply("Please set your image URL using the correct format:\n\nExample: `.aliveimg https://example.com/image.jpg`"); } const key = 'ALIVE_IMG'; handleUpdate(reply, key, q, val => val.startsWith('https://'), "ğŸ˜“ *Invalid URL format. Please provide a valid image URL.*"); }); cmd({ pattern: "alivemsg", desc: "Update the alive message", category: "owner", react: "âœ…", filename: __filename }, async (conn, mek, m, { q, reply, isOwner }) => { if (!isOwner) { return reply("_à¶”à¶¶ à¶¶à·œà¶§à·Š à·„à·’à¶¸à·’à¶šà¶»à·” à¶±à·œà·€à·š...ğŸš«_"); } if (!q) { return reply("Please set your alive message using the correct format:\n\nExample: `.alivemsg Your alive message here`"); } const key = 'ALIVE_MSG'; handleUpdate(reply, key, q, null, null); }); cmd({ pattern: "prefix", desc: "Update the command prefix", category: "owner", react: "âœ…", filename: __filename }, async (conn, mek, m, { q, reply, isOwner }) => { if (!isOwner) { return reply("_à¶”à¶¶ à¶¶à·œà¶§à·Š à·„à·’à¶¸à·’à¶šà¶»à·” à¶±à·œà·€à·š...ğŸš«_"); } if (!q || q.length > 3) { return reply("Please set a valid prefix (1-3 characters) using the correct format:\n\nExample: `.prefix !`"); } const key = 'PREFIX'; handleUpdate(reply, key, q, null, null); }); cmd({ pattern: "autostates", desc: "Enable or disable auto-read status", category: "owner", react: "âœ…", filename: __filename }, async (conn, mek, m, { q, reply, isOwner }) => { if (!isOwner) { return reply("_à¶”à¶¶ à¶¶à·œà¶§à·Š à·„à·’à¶¸à·’à¶šà¶»à·” à¶±à·œà·€à·š...ğŸš«_"); } const key = 'AUTO_READ_STATUS'; const validModes = ['true','false']; handleUpdate(reply, key, q, val => ['true', 'false'].includes(val), "ğŸ˜“ *Invalid value. Please use `true` or `false`.*"); }); cmd({ pattern: "mode", desc: "Update bot mode", category: "owner", react: "âœ…", filename: __filename }, async (conn, mek, m, { q, reply, isOwner }) => { if (!isOwner) { return reply("_à¶”à¶¶ à¶¶à·œà¶§à·Š à·„à·’à¶¸à·’à¶šà¶»à·” à¶±à·œà·€à·š...ğŸš«_"); } const key = 'MODE'; const validModes = ['private', 'public', 'groups', 'inbox']; handleUpdate(reply, key, q, val => validModes.includes(val), `ğŸ˜’ *Invalid mode. Valid modes are: ${validModes.join(', ')}*`); }); cmd({ pattern: "autovoice", desc: "Enable or disable auto voice", category: "owner", react: "âœ…", filename: __filename }, async (conn, mek, m, { q, reply, isOwner }) => { if (!isOwner) { return reply("_à¶”à¶¶ à¶¶à·œà¶§à·Š à·„à·’à¶¸à·’à¶šà¶»à·” à¶±à·œà·€à·š...ğŸš«_"); } const key = 'AUTO_VOICE'; const validModes = ['true','false']; handleUpdate(reply, key, q, val => ['true', 'false'].includes(val), "ğŸ˜“ *Invalid value. Please use `true` or `false`.*"); }); cmd({ pattern: "autoimg", desc: "Enable or disable auto image", category: "owner", react: "âœ…", filename: __filename }, async (conn, mek, m, { q, reply, isOwner }) => { if (!isOwner) { return reply("_à¶”à¶¶ à¶¶à·œà¶§à·Š à·„à·’à¶¸à·’à¶šà¶»à·” à¶±à·œà·€à·š...ğŸš«_"); } const key = 'AUTO_IMAGE'; const validModes = ['true','false']; handleUpdate(reply, key, q, val => ['true', 'false'].includes(val), "ğŸ˜“ *Invalid value. Please use `true` or `false`.*"); }); cmd({ pattern: "autovideo", desc: "Enable or disable auto video", category: "owner", react: "âœ…", filename: __filename }, async (conn, mek, m, { q, reply, isOwner }) => { if (!isOwner) { return reply("_à¶”à¶¶ à¶¶à·œà¶§à·Š à·„à·’à¶¸à·’à¶šà¶»à·” à¶±à·œà·€à·š...ğŸš«_"); } const key = 'AUTO_VIDEO'; const validModes = ['true','false']; handleUpdate(reply, key, q, val => ['true', 'false'].includes(val), "ğŸ˜“ *Invalid value. Please use `on` or `off`.*"); }); cmd({ pattern: "autosticker", desc: "Enable or disable auto sticker", category: "owner", react: "âœ…", filename: __filename }, async (conn, mek, m, { q, reply, isOwner }) => { if (!isOwner) { return reply("_à¶”à¶¶ à¶¶à·œà¶§à·Š à·„à·’à¶¸à·’à¶šà¶»à·” à¶±à·œà·€à·š...ğŸš«_"); } const key = 'AUTO_STICKER'; const validModes = ['true','false']; handleUpdate(reply, key, q, val => ['true', 'false'].includes(val), "ğŸ˜“ *Invalid value. Please use `true` or `false`.*"); }); cmd({ pattern: "autoreply", desc: "Enable or disable auto reply", category: "owner", react: "âœ…", filename: __filename }, async (conn, mek, m, { q, reply, isOwner }) => { if (!isOwner) { return reply("_à¶”à¶¶ à¶¶à·œà¶§à·Š à·„à·’à¶¸à·’à¶šà¶»à·” à¶±à·œà·€à·š...ğŸš«_"); } const key = 'AUTO_REPLY'; const validModes = ['true','false']; handleUpdate(reply, key, q, val => ['true', 'false'].includes(val), "ğŸ˜“ *Invalid value. Please use `true` or `false`.*"); }); cmd({ pattern: "aichat", desc: "Enable or disable AI chat", category: "owner", react: "âœ…", filename: __filename }, async (conn, mek, m, { q, reply, isOwner }) => { if (!isOwner) { return reply("_à¶”à¶¶ à¶¶à·œà¶§à·Š à·„à·’à¶¸à·’à¶šà¶»à·” à¶±à·œà·€à·š...ğŸš«_"); } const key = 'AUTO_AI'; const validModes = ['true','false']; handleUpdate(reply, key, q, val => ['true', 'false'].includes(val), "ğŸ˜“ *Invalid value. Please use `true` or `false`.*"); }); cmd({ pattern: "warncount", desc: "Set the warn count limit", category: "owner", react: "âœ…", filename: __filename }, async (conn, mek, m, { q, reply, isOwner }) => { if (!isOwner) { return reply("_à¶”à¶¶ à¶¶à·œà¶§à·Š à·„à·’à¶¸à·’à¶šà¶»à·” à¶±à·œà·€à·š...ğŸš«_"); } if (!q || isNaN(q) || q <= 0) { return reply("ğŸ˜“ *Invalid number. Please provide a valid number greater than 0 for warn count.*\n\nExample: `.warncount 3`"); } const key = 'WARN_COUNT'; handleUpdate(reply, key, q, val => !isNaN(val), "ğŸ˜“ *Invalid number. Please provide a valid number for warn count.*"); }); cmd({ pattern: "antilink", desc: "Set anti-link action", category: "owner", react: "âœ…", filename: __filename }, async (conn, mek, m, { q, reply, isOwner }) => { if (!isOwner) { return reply("_à¶”à¶¶ à¶¶à·œà¶§à·Š à·„à·’à¶¸à·’à¶šà¶»à·” à¶±à·œà·€à·š...ğŸš«_"); } const key = 'ANTI_LINK'; const validActions = ['delete', 'warn', 'kick', 'off']; handleUpdate(reply, key, q, val => validActions.includes(val), `ğŸ˜“ *Invalid action. Valid actions are: ${validActions.join(', ')}*`); }); cmd({ pattern: "antibad", desc: "Set anti-bad-words action", category: "owner", react: "âœ…", filename: __filename }, async (conn, mek, m, { q, reply, isOwner }) => { if (!isOwner) { return reply("_à¶”à¶¶ à¶¶à·œà¶§à·Š à·„à·’à¶¸à·’à¶šà¶»à·” à¶±à·œà·€à·š...ğŸš«_"); } const key = 'ANTI_BAD'; const validActions = ['delete', 'warn', 'kick', 'off']; handleUpdate(reply, key, q, val => validActions.includes(val), `ğŸ˜“ *Invalid action. Valid actions are: ${validActions.join(', ')}*`); }); cmd({ pattern: "antivoice", desc: "Set anti-voice action", category: "owner", react: "âœ…", filename: __filename }, async (conn, mek, m, { q, reply, isOwner }) => { if (!isOwner) { return reply("_à¶”à¶¶ à¶¶à·œà¶§à·Š à·„à·’à¶¸à·’à¶šà¶»à·” à¶±à·œà·€à·š...ğŸš«_"); } const key = 'ANTI_VOICE'; const validActions = ['delete', 'warn', 'kick', 'off']; handleUpdate(reply, key, q, val => validActions.includes(val), `ğŸ˜“ *Invalid action. Valid actions are: ${validActions.join(', ')}*`); }); cmd({ pattern: "antisticker", desc: "Set anti-sticker action", category: "owner", react: "âœ…", filename: __filename }, async (conn, mek, m, { q, reply, isOwner }) => { if (!isOwner) { return reply("_à¶”à¶¶ à¶¶à·œà¶§à·Š à·„à·’à¶¸à·’à¶šà¶»à·” à¶±à·œà·€à·š...ğŸš«_"); } const key = 'ANTI_STICKER'; const validActions = ['delete', 'warn', 'kick', 'off']; handleUpdate(reply, key, q, val => validActions.includes(val), `ğŸ˜“ *Invalid action. Valid actions are: ${validActions.join(', ')}*`); }); cmd({ pattern: "antiimg", desc: "Set anti-photo action", category: "owner", react: "âœ…", filename: __filename }, async (conn, mek, m, { q, reply, isOwner }) => { if (!isOwner) { return reply("_à¶”à¶¶ à¶¶à·œà¶§à·Š à·„à·’à¶¸à·’à¶šà¶»à·” à¶±à·œà·€à·š...ğŸš«_"); } const key = 'ANTI_PHOTO'; const validActions = ['delete', 'warn', 'kick', 'off']; handleUpdate(reply, key, q, val => validActions.includes(val), `ğŸ˜“ *Invalid action. Valid actions are: ${validActions.join(', ')}*`); }); cmd({ pattern: "antivideo", desc: "Set anti-video action", category: "owner", react: "âœ…", filename: __filename }, async (conn, mek, m, { q, reply, isOwner }) => { if (!isOwner) { return reply("_à¶”à¶¶ à¶¶à·œà¶§à·Š à·„à·’à¶¸à·’à¶šà¶»à·” à¶±à·œà·€à·š...ğŸš«_"); } const key = 'ANTI_VIDEO'; const validActions = ['delete', 'warn', 'kick', 'off']; handleUpdate(reply, key, q, val => validActions.includes(val), `ğŸ˜“ *Invalid action. Valid actions are: ${validActions.join(', ')}*`); }); cmd({ pattern: "ownername", desc: "Update the owner name", category: "owner", react: "âœ…", filename: __filename }, async (conn, mek, m, { q, reply, isOwner }) => { if (!isOwner) { return reply("_à¶”à¶¶ à¶¶à·œà¶§à·Š à·„à·’à¶¸à·’à¶šà¶»à·” à¶±à·œà·€à·š...ğŸš«_"); } if (!q) { return reply("ğŸ˜“ *Please set your name.*\nExample: `.ownername Dila`"); } const key = 'WCPROFILENAME'; handleUpdate(reply, key, q, null, null); }); cmd({ pattern: "ownerfrom", desc: "Update the owner from", category: "owner", react: "âœ…", filename: __filename }, async (conn, mek, m, { q, reply, isOwner }) => { if (!isOwner) { return reply("_à¶”à¶¶ à¶¶à·œà¶§à·Š à·„à·’à¶¸à·’à¶šà¶»à·” à¶±à·œà·€à·š...ğŸš«_"); } if (!q) { return reply("ğŸ˜“ *Please set your location.*\nExample: `.ownerfrom Matara`"); } const key = 'WCPROFILEFROM'; handleUpdate(reply, key, q, null, null); }); cmd({ pattern: "ownerage", desc: "Update the owner age", category: "owner", react: "âœ…", filename: __filename }, async (conn, mek, m, { q, reply, isOwner }) => { if (!isOwner) { return reply("_à¶”à¶¶ à¶¶à·œà¶§à·Š à·„à·’à¶¸à·’à¶šà¶»à·” à¶±à·œà·€à·š...ğŸš«_"); } if (!q) { return reply("ğŸ˜“ *Please set your age.*\nExample: `.ownerage 20`"); } const key = 'WCPROFILEAGE'; handleUpdate(reply, key, q, val => !isNaN(val), "ğŸ˜“ *Invalid age. Please provide a valid number.*"); }); cmd({ pattern: "ownercommand", desc: "Update the owner command", category: "owner", react: "âœ…", filename: __filename }, async (conn, mek, m, { q, reply, isOwner }) => { if (!isOwner) { return reply("_à¶”à¶¶ à¶¶à·œà¶§à·Š à·„à·’à¶¸à·’à¶šà¶»à·” à¶±à·œà·€à·š...ğŸš«_"); } if (!q) { return reply("ğŸ˜“ *Please set the command.*\nExample: `.ownercommand dilo`"); } const key = 'WCPROFILEMSG'; handleUpdate(reply, key, q, null, null); }); cmd({ pattern: "grouptime", desc: "Update the groups open and close times", category: "owner", react: "âœ…", filename: __filename }, async (conn, mek, m, { q, reply, isOwner }) => { if (!isOwner) return reply("_à¶”à¶¶ à¶¶à·œà¶§à·Š à·„à·’à¶¸à·’à¶šà¶»à·” à¶±à·œà·€à·š...ğŸš«_"); if (!q) return reply("Please set your alive message using the correct format:\n\nExample: `.grouptime group id/open time/close time`"); const groups = q.split(','); const regex = /^(\S+@\S+\/\d{2}:\d{2}\/\d{2}:\d{2})$/; let groupTimeUpdates = []; for (const group of groups) { if (!regex.test(group.trim())) return reply("Invalid format. Please use: `.grouptime group id/open time/close time`"); const [groupId, openTime, closeTime] = group.split('/'); groupTimeUpdates.push(`${groupId}/${openTime}/${closeTime}`); } const updatedGroupTime = groupTimeUpdates.join(','); try { await handleUpdate(reply, 'GROUP_TIME', updatedGroupTime); reply("Group times updated successfully."); } catch (error) { console.error(error); reply("ğŸ™‡â€â™‚ï¸ *Failed to update GROUP_TIME. Please try again.*"); } });
